# 1. 两数之和

力扣链接： https://leetcode.cn/problems/two-sum/submissions/665285009/

## 题目
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。

你可以按任意顺序返回答案。

**示例 1：**

> **输入：** nums = \[2,7,11,15], target = 9
> **输出：** \[0,1]
> **解释：** 因为 nums\[0] + nums\[1] == 9 ，返回 \[0, 1] 。

**示例 2：**

> **输入：** nums = \[3,2,4], target = 6
> **输出：** \[1,2]
---
## 思路
本题想到最简单的方法是双层嵌套循环，遍历每一个数字：
```Python
n = len(nums)
for i in range(n):
	for j in range(i + 1, n):
		if nums[i] + nums[j] == target:
			return [i, j]
```

双层嵌套循环的思路是先固定一个数 `num[i]`，然后从余下的数里找是否有符合相加等于 target 的。那么，如果能不使用循环，直接去找 target - num\[i] 是否存在，不是更简单吗？

而根据数字查索引的方法，就是哈希表。

**本体题解的中心思想是一边把数组存到哈希表中，一边检验哈希表里是否有满足条件的数。**

有人问，既然是一边存一边检验，是否会发生遗漏？答案是不会的。假设这样一个情况：数组中的 a 和 b 相加为 target，a 的索引小于 b，函数的工作情况如下：
1. 先收到 a，函数检查哈希表中是否有 b，发现没有，把 a 存入哈希表
2. 之后收到 b，函数检查哈希表中是否有 a，发现有，输出结果
因为题目可以按任意顺序返回索引值，所以无论是 a 或 b 在索引更小的位置，都不会被遗漏。
## 题解
```Python
## 题解
class Solution(object):
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        hashtable = dict()
        for i, num in enumerate(nums):
            if target - num in hashtable:
                return [hashtable[target - num], i]
            hashtable[nums[i]] = i

        return []
```

## 易错点
#易错点 
- 在 for 循环内，if 必须在哈希表存键值之前。否则，num 会和自己凑成一对相加满足 target 的数。

```Python
# 错误的写法：if 在 hashtable 之后
for i num in enumerate(nums):
	hashtable[nums[i]] = i
	if target - num in hashtable:
		return ...
```

如果现存 num 再检验，则在检验时 num 自身也在范围内。

比如 target 是 4，num 是 2，假设哈希表原来没有 2 这个数。在 2 存入哈希表后，if 检验发现表里存在 target - num = 2，返回的索引变成两个一模一样的索引值。这就不符合题意了。