---
tags:
  - 双指针/快慢指针
---

# 141. 环形链表

力扣链接： https://leetcode.cn/problems/linked-list-cycle/

## 题目
给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

---
## 思路

这道题用 [[快慢指针]]。把快慢指针想象成龟兔赛跑，如果乌龟永远追不上兔子，那么这个赛道就没有环；如果乌龟能追上兔子，说明这个赛道有环。

#### 步长
规定慢指针每次走一步，快指针每次走两步。

#### 终点
当 `slow == fast` 时，循环结束。在循环内部需要检验 `fast` 是否已经走到链表的末尾。

#### 起点
- 慢指针：`head`
- 快指针：`head.next`
如果两个指针都从 `head` 开始走，那么按照终点的规定，循环不会开始。那么为何现在设置的起点是合理的呢？可以假设在 `head` 前有一个虚拟头结点 `dummy`，目前的慢指针位置就是从 `dummy` 走了一步的位置，而快指针的位置是从 `dummy` 走了两步的位置。这个设想是符合对步长的规定的。

如下所示：
```Python
dummy -> head -> head.next
		 ^       ^
		 slow    fast
```

## 题解
```Python
## 题解
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        if not head or not head.next:
            return False

        slow, fast = head, head.next

        while slow != fast:
            if not fast or not fast.next:
                return False
            slow = slow.next
            fast = fast.next.next
        return True
```

## 易错点
#易错点 
- 在两个 if 中检验 `fast.next = None`：因为循环内部涉及 `fast.next.next`，如果 `fast.next.next = None.next` 那就完了。因为 `None` 不指向任何元素，如果运行时出现 `None.next` 会报错。所以要在 `fast.next` 为 `None` 时跳出循环。
	- 这个情况也出现在 [[234. 回文链表]] 中
- 容易忘记最前面的对空链表或单一元素链表的单独讨论