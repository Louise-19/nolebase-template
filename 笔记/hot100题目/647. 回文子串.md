# 647. 回文子串

力扣链接： https://leetcode.cn/problems/palindromic-substrings/description/

# 题目
给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的数目。

**回文字符串** 是正着读和倒过来读一样的字符串。

**子字符串** 是字符串中的由连续字符组成的一个序列。

**示例 1：**

> **输入：** s = "abc"
> **输出：** 3
> **解释：** 三个回文子串: "a", "b", "c"

#### 题目注意事项
注意，题中返回的是子串的 **个数** 而不是打印每一个子串。
# 思路
由于涉及到对比两个元素，所以用双指针。

在这道题中，回文子串有两种情况，一种是像 "aba" 这种奇数子串，还有是像 “abba” 这种偶数子串，所以需要**分类讨论**。分类讨论时，两个分类是平行的，在缩进上是对齐的。

**如何检验回文**：用 for 循环遍历数组，确定一个中心字符，然后左右指针从该中心字符开始，分别向左右移动，每移动一次，判断左右指针指向的元素是否相等。若相等，则就有了新的子串。

如下，c 是中心字符 `i`，左右指针分别向两侧移动。
```
[a, b, a, c, a, b, d, a]
       ^  i  ^
     left   right
```

```Python
## 题解
class Solution(object):
    def countSubstrings(self, s):
        """
        :type s: str
        :rtype: int
        """
        count = 0
        n = len(s)

        for i in range(n):
            # case1：奇数子串
            left, right = i, i
            while left >= 0 and right < n and s[left] == s[right]:
                count += 1
                left -= 1
                right += 1
            
            # case2：偶数子串
            left, right = i, i + 1
            while left >= 0 and right < n and s[left] == s[right]:
                count += 1
                left -= 1
                right += 1
        return count
```

# 易错点
#易错点 
- 注意两个 while 的条件是 `left >= 0 and right < n`，因为在这里 `left` 恒小于 `right`。注意不能写成 `right <= n`
