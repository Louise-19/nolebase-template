# 15. 三数之和

力扣链接： https://leetcode.cn/problems/3sum/description/

# 题目
给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：** 答案中不可以包含重复的三元组。
#### 题目注意事项

如果数组是：
```csharp
[0, 1, 2, 2, 2, 3]
```
则在举例第一个 \[0, 1, 2]后，还会出现第二个第三个 \[0, 1, 2]。为了排除这种情况，要让循环跳到下一个不相同的元素。
# 思路
本题首先想到的是用三循环暴力求解：
```Python
for x in range(n - 2):
	for y in range(i + 1, n - 1):
		for z in range(j + 1, n):
			if nums[x] + nums[y] + nums[z] == target:
				ans.append([nums[x], nums[y], nums[z]])
```
但暴力解法的时间复杂度很高，所以保留三重循环，但根据题目的特性采用双指针。

双指针的思路如下：
1. 先把数组**按序排列**，方便用双指针进行。
2. **最外层的循环**：因为寻找的是三数之和，先固定第一个数，即最外层的循环，截止到 `n-3` 的位置。这是为了当循环到 `n-3` 时给左右指针各留下一个位置（ `n-2` 和 `n-1` ），防止数组溢出。但在写的时候，是 `range(n - 2)`，因为 range 规定 `n - 2` 不算在内。
3. **两个优化**：
	1. 如果第一个数就已经大于零，则不可能找到大于 0 的组合，没有再循环的必要，直接退出。
	2. **跳过同个数字连续的段落**：在最外层循环中，可能会碰到 `[-2, -1, -1, 0, 1, 1, 1, 2]` 这样的组合，可以发现 -1 和 1 重复出现了多次，如果不跳过重复的段落，则最终结果会出现重复组合，所以在确定第一个数时，要校验这个数是否和前一个数一样，是则跳过。
4. **规定左右指针的起点**：左指针是固定的第一个数后的数字，即 `left = i + 1`，右指针是数组的最后一个数字，即 `right = n - 1`。两个指针相向往中间靠近。
5. **第二层循环，左右指针移动的规则**：现在有三个数，分别是最外层循环固定的第一个数，左指针指向的数和右指针指向的数，将它们相加得到 `s`。如果 `s < 0`，说明数需要增大，令左指针右移可以达到增大的效果（因为数组按序排列）；如果 `s > 0`，说明数需要变小，令右指针左移。如果 `s == 0`，则把当前结果记录到 `ans[]` 中。
6. **第三层循环，找到目标后，继续移动左右指针的规则**：在得到第一个结果后，继续移动左右指针，寻找是否有别的组合。左指针右移，右指针左移。但这里需要加上和 3.2 一样的优化：跳过数字连续的段落。

```Python
## 题解
class Solution(object):
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        nums.sort()
        ans = []
        n = len(nums)

        for i in range(n - 2):
            x = nums[i]
            # 优化，因为数组按序排列，若第一个数大于0，则后面必找不出和为0的组
            if nums[i] > 0:
                break
            # 检验，排除同一数字连续所造成的重复
            if i > 0 and x == nums[i - 1]:
                continue

            left = i + 1
            right = n - 1
            
            while left < right:
                s = x + nums[left] + nums[right]
                if s == 0:
                    ans.append([x, nums[left], nums[right]])
                    
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    
                    left += 1
                    right -= 1
                elif s > 0:
                    right -= 1
                elif s < 0:
                    left += 1
        return ans

```

```
# 易错点
#易错点 如果没有，删去此标签
```