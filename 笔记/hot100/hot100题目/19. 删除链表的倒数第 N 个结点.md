---
tags:
  - 双指针/快慢指针
  - status/to-optimize
---

# 19. 删除链表的倒数第 N 个结点

力扣链接： https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/

## 题目
给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**输入：** head = \[1,2,3,4,5], n = 2
**输出：**\[1,2,3,5]

---
## 思路
==思路有待改变，感觉目前的说法还不够清晰。可能需要用伪代码解释框架是如何搭建的。==

由于涉及到查找第 n 个结点，因此想到 #双指针/快慢指针 。

本题的思路是定义两个指针 `fast` 和 `slow`，让 `fast` 先走 n 步，然后两个指针一起走，直到 `slow` 指向倒数第 n + 1 个元素时停下，执行删除结点操作。这个操作很简单，只要让该元素指向它的下下个元素，即 `slow.next = slow.next.next` 就行。

本题的难点是两个边界条件的设置：
1. **如何让 `fast` 先走 n 步？**：
	- 这个好办，对于要**重复执行指定次数的操作**，用 for 循环就能解决。

```Python
for i in range(n):
	fast = fast.next
```

2. **如何控制 `slow` 停在倒数 n + 1 的位置？**
	- 画个图思考一下：假设在某链表中，删除倒数第 2 个元素
```Python
# 原链表
1 -> 2 -> 3 -> 4 -> 5
		  ^         ^
		  slow      fast
```
可见，当 `fast` 走到链表末尾时，`slow` 停在倒数 n + 1 位置。已知此时 `fast.next = None`，所以让 while 循环的条件是 `fast.next is not None` 就能让 `slow` 停在目标位置。 

#### 特殊情况：删去的是头结点
假设链表仍是 5 个元素，要求删去倒数第五个元素，即头结点。

因为头结点的操作和普通结点不一样，所以需要单独判断。我们先让 `fast` 走 n = 5 步，如下：
```Python
1 -> 2 -> 3 -> 4 -> 5 -> None
				         ^
			             fast
```
发现此时 `fast` 指向 None。而在删除结点不为头结点时，`fast` 不会指向 None。那么利用此特性，判断当 `fast = None` 时，直接返回 `head.next`，即为删除头结点后的链表。

这个特殊情况需要在讨论普通情况前进行，不然后续无法使用 `fast.next`。
## 题解
```Python
## 题解
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def removeNthFromEnd(self, head, n):
        """
        :type head: Optional[ListNode]
        :type n: int
        :rtype: Optional[ListNode]
        """
        fast, slow = head, head

        for i in range(n):
            fast = fast.next

        if not fast:
            return head.next
            
        while fast.next:
            fast = fast.next
            slow = slow.next
        
        # 循环结束，slow 走到第倒数 n + 1 个结点
        slow.next = slow.next.next
        return head
```

## 易错点
#易错点 
- 不能忽略中间的 if 检验，针对删去的是**头结点**的情况
- 第二个 while 循环的条件是 `fast.next`