# 34. 在排序数组中查找元素的第一个和最后一个位置

力扣链接： https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/

# 题目
给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

#### 题目注意事项
- 返回的是开始位置和结束位置，不是下标。即是从头开始，自然数数的顺序。

# 思路
本题可以理解为，找出数组中第一个大于等于 `target` 的下标，和第一个大于 `target` 的下标。由于这两个目标相近，所以可以抽象为一个函数来解决。

最后需要验证一下 `target` 是否在数组中。

#### 左闭右开的写法：
```Python
## 题解
class Solution(object):
    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        def left_func(nums, target):
            left, right = 0, len(nums)
            while left < right:
                mid = (left + right) // 2
                if nums[mid] >= target:
                    right = mid
                else:
                    left = left + 1
            return left
        a = left_func(nums, target)
        b = left_func(nums, target + 1)
        if nums[a] != target or a == len(nums):
            return [-1, -1]
        else:
            return [a, b - 1]
```

**解释一下最后的 if 验证条件：`if nums[a] != target or a == len(nums):`**

首先想到的是，验证 `target` 是否在数组内，而验证的方法就是看左边界 `a` 是否能找到 `target`， 即 `nums[a] != target`。

但同时有另一个顾虑，如果 `a` 已经超出了数组 `nums` 的范围，那么上面那句验证条件就会报错。因为按照 `left_func()` 的函数构造，是有可能出现 `a` 大于数组长度的情况的。因此要再加一个验证条件，即 `a == len(nums)`。

为什么会想到第二个验证条件，是考虑到第一个验证条件可能会报错的情况。
# 易错点
#易错点/数组 
- 在 while 循环中的 if 条件时，是 `nums[mid] >= target`，而不是 `mid >= target`